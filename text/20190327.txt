소켓이 클라이언트 입장에서는 1개만 있으면 됨.
서버 입장에서는 통신을 받기 위한 소켓이 한개 더 있어야 한다.

루프백 주소 127.0.0.1 Test용 주소 내 하나의 컴퓨터 내에서 클라이언트 서버를 실행시키고자 할때 사용한다.
----------------------------------------------------------------

서버입장.

대기소켓 -> port 번호 IP번호 가 있어야 한다. 


클라이언트 입장.


----------------------------------------------------

connect 에서 IP주소를 220.68.231.238 로 설정을 하면 한세대학교 게이트 웨이로 전달되어
서브넷 마스크로 220.68.231.xxx로 설정이 되있는 것을 확인하고 local 망에 있음을 확인하고 다시 안으로 보내지게 된다. -> 이럴때는 Network 카드가 없으면 안된다.


------------------------------------------------------------------

Server 의 대기 소켓이 있는데 클라이언트의 통신 가능한 소켓이 Server에서 통신 소켓에서 반응을 하게 된다.

SOCKET listen_sock = socket(
        AF_INET, 
//주소체계: 통신 영역 설정, 인터넷 영역을 사용하며 리모트 컴퓨터 사이의 통신을 사용, IPv4
        SOCK_STREAM,
 //프로토콜유형: TCP/IP 기반 사용
        0 //0을 입력하면 자동적으로 TCP 프로토콜을 쓰겠다.
//앞 두 인자로 프로토콜 결정이 명확하면 0사용, IPPROTO_TCP, IPPROTO_UDP
        );

----------------------------------------------------------------------------
--------------------------서버 코드 분석-----------------------

ZeroMemory 초기화 작업

1024 0~1023 =>well - konwn 포토번호에 대한 약속

포토번호를 2바이트 크기를 사용한다. 약 6만 5천.... 의 포토번호를 가질수 있다.

서버의 대기소켓은 IP 정보와 포토번호를 가지고 있다.
IP = 0 을 사용해서 자신을 가리키고 포트번호는 9000을 사용하고 있다.
--------------------------------------------------------------------------
// listen() // 200번이라는 대기소켓에 접속대기큐를 5개 만든다.
	retval = listen(
        listen_sock, 
        SOMAXCONN //접속대기 큐의 크기 1이상의 수를 입력하기만 하면 된다.
        ); // TCP 상태를 LISTENING 변경
	if(retval == SOCKET_ERROR) err_quit("listen()");

------------------------------------------------------------------------
client_sock = accept(//접속 대기 큐의 내용을 꺼내오는 작업이다.동기 함수 vs 비동기 함수
	//통신소켓이 통신을 요청하기 전까지 계속 대기하는 동기함수의 블록함수이다.
            listen_sock, //대기 소켓
            (SOCKADDR *)&clientaddr, //클라이언트의 정보 out param
            &addrlen //주소구조체형식의크기, in(크기지정), out(초기화한크기반환) param
            ); //통신소켓 생성: 원격 IP, 원격 포트 결정

-----------------------------------------------------------------------

while(1){ //데이터가 들어오는지 확인하는 블록함수
			// 데이터 받기 클라이언트에서 보낸 메시지까지 가져온다.
			retval = recv(
                client_sock, //통신소켓핸들
                buf, //받을 애플리케이션 버퍼
                BUFSIZE, //수신 버퍼의 최대 크기
                0 //대부분 0 or MSG_PEEK와 MSG_OOB를 사용 가능
                );

--------------------------------------------------------------------------------------
----------------------------클라이언트 코드 분석-----------------------------------

	serveraddr.sin_family = AF_INET;
	serveraddr.sin_port = htons(9000);
	serveraddr.sin_addr.s_addr = inet_addr("220.68.231.238");
	// 서버의 IP주소를 던짐

------------------------------------------------------------------------------------
retval = send( send 라는 os의 버퍼에다가 데이터를 넣는다. 나르는 역활은 os에서 처리한다
            sock, //통신소켓핸들
            buf, // 보낼 애플리케이션 버퍼
            strlen(buf), //보낼 데이터 크기
            0 //대부분 0 or MSG_DONTROUTE나 MSG_OOB를 사용 가능
            );


